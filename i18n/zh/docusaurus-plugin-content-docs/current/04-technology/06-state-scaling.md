# 为 Layer1 状态扩容

区块链要承载大规模的用户，除了要解决交易执行的吞吐量难题，同时还有一个业界尚未普遍关注的难题就是状态扩容。显而易见，如果亿级用户在链上持有很多各种类型的资产以及应用的状态，状态爆炸问题很快要面对。

这个问题在 Token 时代还不明显，毕竟 Token 是可以拆分合并，且只需要用一个数字来表达。到了 NFT 爆发的时代，这个问题就很明显了，大量的 NFT 发行者希望将 NFT 的元数据乃至图片都保存在链上。等下一步 Web3 应用爆发，各种应用创造出来的新型资产或者应用状态，如果都想保存在链上，就必须解决状态爆炸的问题。

当前 Layer1 上解决状态爆炸的主要思路是实现状态计费，通过成本逼迫用户谨慎使用链上状态，激励用户删除无用的状态。但这个方法并不能从根本上解决状态爆炸问题，只能延缓这个问题。

Rooch 利用 Move 的状态特性，设计出一种跨层的状态迁移方案，可以将状态从 Layer1 迁移到 Layer2，从而实现给 Layer1 状态扩容。

## 状态迁移

状态迁移的思路是在链上维护一个链上只记录根，链下存储全量数据的状态树，我们可以称为 **Rollup State Tree**，简称 RST。

![state move](/diagram/rooch-state-move.svg)

当链上的用户状态迁移到 RST 中后，状态从链上消失，如上图中的 NFT1。Rooch 的验证节点会在链下应用状态树的操作，NFT1 出现在链下的状态树中，用户可以从链下状态树中取回，实现状态迁移。
当链下状态需要迁移回链上时，需要携带状态树的叶节点存在证明，在链上执行操作。

### Rollup State Tree

RST 是一颗稀疏默克尔树（Sparse Merkle Tree）。稀疏默克尔树可以提供不存在证明，有了不存在证明，可以在没有全局数据的情况下，实现链上更新。

如果要在 RST 中插入一个不存在的叶子节点，需要提供当前根下，该叶节点的不存在证明，以及新的节点的值，合约中可以校验不存在证明，并计算出新的根。

```
non-inclusion proof + new value = inclusion proof => new root
```

如果要更新一个叶节点，需要提供该节点的存在证明，以及新的值，通过新值替换证明中的叶节点，可以计算出新的根。

如果要删除一个叶节点，需要提供该节点的存在证明，将该节点的值替换为稀疏默克尔树的默认填充值，可以计算出新的根。

RST 的使用场景：

1. 如果所有的更新操作都发生在链上，RST 可以作为一个完全由合约保证安全的链下状态存储方案。
2. 如果提供直接更新 RST 根哈希的方法，但条件是通过挑战期实现最终确定的根，那它就可以作为执行层的状态迁移方案。
3. 如果提供直接更新 RST 根哈希的方法，但条件是参与方都签名的根，那它就可以作为状态通道中的状态迁移方案。

由于 Move 和 EVM 的状态机制不一样，所以这套方案在两种不同链上使用方式也不一样。

### Move 链的状态迁移

:::note

这里也需要一张图

:::

Move 通过线性类型实现的面向资源的编程模式，可以实现状态在合约之间移动，我们称这种状态为“自由状态”，而最常见的“自由状态”主要是资产类型的状态，Token 或者 NFT。

如果 Layer1 是 Move 智能合约链，我们也可以利用这个特性，实现跨层的“自由状态”迁移。应用只需要将状态转移给 Rooch Framework 里的 RST，由 Rooch Framework 提供合约实现状态的跨层移动。

### EVM 链的状态迁移

EVM 中的状态不能跨合约移动，但每个合约内部可以维护一个 RST，从而实现状态迁移。等状态映射到执行层后，可以通过 Move 变为“自由状态”。

:::note

这里还需要一张图

:::

但这个方式只适合新的合约，如何支持已经部署的合约，需要进一步研究。

:::note

TODO 通过 Solidity 代码来表达 

:::

### 相关链接

* [RollupMap](https://github.com/movefuns/movefuns/issues/10)
